from locust import User, between, taskimport timefrom faker import Fakerimport loggingimport redisfrom typing import Any, Dict, List, Optionaldef redis_task(weight=1):    def middle(func):        @task(weight=weight)        def run_redis_operation(self):            start_time = time.time()            name = func.__name__            try:                func(self)            except Exception as e:                print(e)                total_time = int((time.time() - start_time) * 1000)                self.environment.events.request.fire(                    request_type='redis', name=name, response_time=total_time, exception=e, response_length=0,                )        return run_redis_operation    return middleclass RedisUser(User):    abstract = True    wait_time = between(0.0, 0.0)    def __init__(self, environment):        super().__init__(environment)        self.faker = Faker()        # TODO: Add host to Redis or adjust it to RedisEnterprise ASAP        self.redis = FocalMemorystore(host='', port=6379, db=0)class FocalMemorystore:    local: Dict = None    pool: Optional[redis.ConnectionPool] = None    redis_tracing: bool = False    def __init__(self, host: Optional[str], port: Optional[int], db: Optional[int] = 0, use_local: bool = False,                 redis_tracing: bool = False):        if not host:            if use_local:                self.local = dict()            return        self.pool = redis.ConnectionPool(host=host, port=port, db=db)        self.redis_tracing = redis_tracing    def close(self):        if self._is_connected():            self.pool.disconnect()            self.pool = None    def _is_connected(self) -> bool:        return self.pool is not None    def clear_local(self):        if self.local is not None:            self.local = dict()    def clear_queue(self, queue_name: str):        if not self._is_connected():            return        try:            with self.get_connection() as redis_connection:                redis_connection.ltrim(queue_name, -1, 0)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def get_connection(self) -> redis.Redis:        return redis.Redis(connection_pool=self.pool)    def get_keys(self, pattern: str) -> List[str]:        if not self._is_connected():            return self.local.keys() if self.local else []        try:            with self.get_connection() as redis_connection:                values_bytes = redis_connection.keys(pattern)                return [v.decode('utf-8') for v in values_bytes]        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return []    def get_entries(self, pattern: str) -> List[str]:        return [self.get_entry(key) for key in self.get_keys(pattern)]    def get_entry(self, key: str) -> Optional[str]:        value = self.get_entry_bytes(key)        if not value:            return None        return value.decode('utf-8')    def get_entry_bytes(self, key: str) -> Optional[bytes]:        if not self._is_connected():            return self.local.get(key) if self.local else None        try:            with self.get_connection() as redis_connection:                return redis_connection.get(key)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return None    def get_entry_int(self, key: str) -> Optional[int]:        value = self.get_entry_bytes(key)        if not value:            return None        return int(value)    def get_from_queue(self, queue_name: str, count: int = 1) -> List[Any]:        if not self._is_connected():            return []        try:            with self.get_connection() as redis_connection:                if count == -1:                    count = redis_connection.llen(queue_name)                if count == 0:                    return []                if count > 1:                    with redis_connection.pipeline() as pipe:                        for _ in range(count):                            pipe.lpop(queue_name)                        return pipe.execute(False)                return [redis_connection.lpop(queue_name)]        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return []    def get_hash_all(self, hash_name: str) -> Optional[Any]:        if not self._is_connected():            return None        try:            with self.get_connection() as redis_connection:                return redis_connection.hgetall(hash_name)        except redis.ConnectionError:            logging.error(f'Unable to connect to Redis (Memorystore)')            return None    def get_hash_entries(self, hash_name: str, key_list: List[str]) -> Optional[Any]:        if not self._is_connected():            return None        try:            with self.get_connection() as redis_connection:                return redis_connection.hmget(hash_name, key_list)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return None    def get_hash_entry(self, hash_name: str, key_name: str) -> Optional[Any]:        if not self._is_connected():            return None        try:            with self.get_connection() as redis_connection:                return redis_connection.hget(hash_name, key_name)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return None    def has_entry(self, key: str) -> bool:        if not self._is_connected():            return key in self.local if self.local else False        try:            with self.get_connection() as redis_connection:                return redis_connection.exists(key) >= 1        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return False    def has_hash_entry(self, hash_name: str, key_name: str) -> bool:        if not self._is_connected():            return False        try:            with self.get_connection() as redis_connection:                return redis_connection.hexists(hash_name, key_name)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return False    def inspect_queue(self, queue_name: str) -> List[Any]:        if not self._is_connected():            return []        try:            with self.get_connection() as redis_connection:                return redis_connection.lrange(queue_name, 0, -1)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return []    def move_entry(self, old_queue_name: str, new_queue_name: str, value: Any):        if not self._is_connected():            return        try:            with self.get_connection() as redis_connection:                removed = redis_connection.lrem(old_queue_name, 1, value)                if removed:                    redis_connection.rpush(new_queue_name, *[value])        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def pop_entire_list(self, key: str) -> List[Any]:        if not self._is_connected():            return []        try:            with self.get_connection() as redis_connection:                with redis_connection.pipeline() as pipe:                    pipe.lrange(key, 0, -1)                    pipe.delete(key)                    return pipe.execute(False)[0]        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')            return []    def put_entry(self, key: str, value: Any, expire_in_s: Optional[int]):        if not self._is_connected():            if self.local is not None:                self.local[key] = bytes(str(value), 'utf-8')            return        try:            with self.get_connection() as redis_connection:                redis_connection.set(key, value, ex=expire_in_s)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def put_hash_entry(self, hash_name: str, key_name: str, value: Any):        if not self._is_connected():            return        try:            with self.get_connection() as redis_connection:                redis_connection.hset(hash_name, key_name, value)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def put_into_list(self, list_name: str, value: Any, list_max_size: Optional[int] = None):        if not self._is_connected():            return        try:            with self.get_connection() as redis_connection:                redis_connection.lpush(list_name, value)                if list_max_size is not None and list_max_size >= 0:                    redis_connection.ltrim(list_name, 0, list_max_size - 1)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def remove_entry(self, key: str):        if not self._is_connected():            if self.local is not None:                del self.local[key]            return        try:            with self.get_connection() as redis_connection:                redis_connection.delete(key)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def remove_from_hash(self, key: str, entry: str):        if not self._is_connected():            return        try:            with self.get_connection() as redis_connection:                redis_connection.hdel(key, entry)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def put_into_queue(self, queue_name: str, items: List[Any]):        if not self._is_connected():            return        try:            if not self.redis_tracing:                with self.get_connection() as redis_connection:                    redis_connection.rpush(queue_name, *items)            else:                with self.get_connection() as redis_connection:                    redis_connection.rpush(queue_name, *items)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def expire_entry(self, key: str, expire_in_s: int):        if not self._is_connected():            return        try:            if not self.redis_tracing:                with self.get_connection() as redis_connection:                    redis_connection.expire(key, expire_in_s)            else:                with self.get_connection() as redis_connection:                    redis_connection.expire(key, expire_in_s)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')    def remove_from_queue(self, queue_name: str, item: Any):        if not self._is_connected():            return        try:            with self.get_connection() as redis_connection:                redis_connection.lrem(queue_name, 1, item)        except redis.RedisError as err:            logging.error(f'Redis problem encountered: {err}')